<!DOCTYPE html>

<!--
    collapsible directed acyclical graph for family tree visualization
    author: Benjamin W. Portner
    license: GNU General Public License v3.0

    based on d3 collapsible treemap example by d3noob: https://bl.ocks.org/d3noob/43a860bc0024792f8803bba8ca0d5ecd
    features in the original:
    - d3 tree
    - collapsible
    - transitions
    new features:
    - two types of nodes: unions and persons
    - d3 dag instead of tree (to allow two parents per union)
    - collapse/expand in all directions (memory function)
    - tooltips: show node metadata on hover
-->

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/main.css">
    <!-- Comment -->
</head>

<body>

  <!-- Dropdown UI -->
  <div id="selectOverlay">
    <label for="dropdown">Choose a root person:</label>
    <select id="dropdown">
      <option value="" disabled selected>-- Select Person --</option>
      <option value="id26">George Herbert</option>
      <option value="id13">Margaret Rose</option>
      <option value="id7">William the Bold</option>
    </select>
  </div>

  <script>
    let selectedOption = null;

    // Handle dropdown selection
    document.getElementById("dropdown").addEventListener("change", function () {
      selectedOption = this.value;
      document.getElementById("selectOverlay").style.display = "none";

      loadScriptsSequentially([
        "https://d3js.org/d3.v7.min.js",
        "js/d3-dag.js",
        "data/data_wilson.js",
        "js/familytree.js"
      ], () => {
        defineBuildSubtree(); // define it globally
        runPageLogic(selectedOption);
      });
    });

    // Dynamically load scripts in sequence
    function loadScriptsSequentially(scripts, callback) {
      const load = (i) => {
        if (i >= scripts.length) return callback();
        const s = document.createElement("script");
        s.src = scripts[i];
        s.onload = () => load(i + 1);
        s.onerror = () => console.error("Failed to load script:", scripts[i]);
        document.head.appendChild(s);
      };
      load(0);
    }

    // Define buildSubtree globally
    function defineBuildSubtree() {
      window.buildSubtree = function (fullData, personId) {
        const visitedPersons = new Set();
        const visitedUnions = new Set();
        const persons = [];
        const unions = [];

        const queue = [personId];

        while (queue.length > 0) {
          const pid = queue.pop();
          if (visitedPersons.has(pid)) continue;
          visitedPersons.add(pid);

          const person = fullData.persons[pid];
          if (!person) continue;

          persons.push(person);

          if (Array.isArray(person.own_unions)) {
            for (const uid of person.own_unions) {
              if (visitedUnions.has(uid)) continue;
              visitedUnions.add(uid);

              const union = fullData.unions[uid];
              if (!union) continue;

              unions.push(union);

              if (Array.isArray(union.parents)) queue.push(...union.parents);
              if (Array.isArray(union.children)) queue.push(...union.children);
            }
          }
        }

        persons.forEach(p => { if (!Array.isArray(p.own_unions)) p.own_unions = []; });
        unions.forEach(u => {
          if (!Array.isArray(u.parents)) u.parents = [];
          if (!Array.isArray(u.children)) u.children = [];
        });

        const personIds = new Set(persons.map(p => p.id));
        const unionIds = new Set(unions.map(u => u.id));

        const links = (fullData.links || []).filter(link =>
          personIds.has(link.source) || unionIds.has(link.source) ||
          personIds.has(link.target) || unionIds.has(link.target)
        );

        return {
          persons: persons.reduce((acc, p) => { acc[p.id] = p; return acc; }, {}),
          unions: unions.reduce((acc, u) => { acc[u.id] = u; return acc; }, {}),
          links
        };
      };
    }

    // Main rendering logic
    function runPageLogic(selectedId) {
      const svg = d3.select("body").append("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

      const subtree = buildSubtree(data, selectedId);
      const FT = new FamilyTree(subtree, svg)
        .orientation("vertical");
      FT.draw();
    }
  </script>

    

    

</body>